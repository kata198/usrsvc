#!/usr/bin/env python



import os
import sys
import signal
import subprocess
import threading
import time
import traceback

from collections import defaultdict

from usrsvcmod.config import config as usrsvcconfig
from usrsvcmod.Program import Program
from usrsvcmod.ProgramActions import getRunningProgram
from usrsvcmod.logging import logMsg, logErr

def printUsage():
    sys.stderr.write('''Usage: usrsvcd (Optional: [action])
Optional daemon portion of usrsvc which actively monitors processes and provides the autostart/autorestart, and other optional features.

  Actions:
    Running with no arguments starts the usrsvcd daemon. You can also provide one of several "action" arguments which affect the running instance of usrsvcd.

      checkconfig            -   Try to parse config files and validate correctness, without affecting the running usrsvcd instance. Returns non-zero on failure.
      reread                 -   Sends SIGUSR1 to the running usrsvcd process, which will cause it to reread configs and immediately apply the changes to the running instance.
                                    If there are errors in the configs, a message will be logged by the usrsvcd process and it will retain its current configuration state.
      restart                -   Restarts the usrsvcd daemon cleanly
      status                 -   Checks if usrsvcd is running. Returns non-zero on failure

Uses main config file in $HOME/usrsvc.cfg''')
    sys.stderr.write('( %s/%s )\n' %(os.environ['HOME'], '/usrsvc.cfg'))


# Global config, so all methods get the reload
global config
config = None

# Global flag for graceful termination
global keepGoing
keepGoing = True

# Global list of processes we are currently restarting, so we don't flood it with extra actions.
#  This is not 100%, there is a slight race, but should not matter (at worst, a double start is issued)
global restarting
restarting = set()

def handle_sigterm(*args, **kwargs):
    global keepGoing
    keepGoing = False

    logErr('usrsvcd got SIGTERM, shutting down.\n')
    signal.signal(signal.SIGTERM, signal.SIG_IGN)
    return True
 

def rereadConfig(*args, **kwargs):
    global config

    logMsg('Got SIGUSR1, reprocessing config.\n')

    config2 = getConfig()
    if not config2:
        return

    config = config2
    configureStdoutStderr(config.mainConfig)
    

def getConfig():
    configPath = os.environ['HOME'] + '/usrsvc.cfg'

    if not os.path.exists(configPath) or not os.access(configPath, os.R_OK):
        logErr('Missing config file: %s\n' %(configPath,))
        return None

    config = usrsvcconfig(os.environ['HOME'] + '/usrsvc.cfg')
    try:
        config.parse()
    except ValueError as e:
        logErr('Error in configuration: %s\n' %(str(e),))
        return None

    return config
    
def getUsrsvcdProg():
    global config

    mainPidFile = config.mainConfig.pidfile
    try:
        prog = Program.createFromPidFile(mainPidFile)
        if prog and 'usrsvcd' in prog.cmdline:
            return prog
    except:
        pass

    return None


def doMonitoring():
    global config
    global keepGoing
    global restarting

    # Wait a bit at first for us to roll through the apps
    time.sleep(8)
    restartProcesses = {}

    while keepGoing is True:
        try:
            programConfigs = config.getProgramConfigs()
            for programName, programConfig in programConfigs.items():
                if programName in restartProcesses:
                    try:
                        # Try/except here, incase an OOM or otherwise breaks the poll, we hold on tight.
                        if restartProcesses[programName].poll() is None:
                            continue
                    except:
                        pass
                    del restartProcesses[programName]
                    restarting.remove(programName)
                    continue # We can just skip here, it just completed a restart. Give it a chance to get goin'

                if not programConfig.Monitoring.isMonitoringActive():
                    continue

                runningProgram = None
                try:
                    runningProgram = getRunningProgram(programConfig)
                except:
                    pass

                if not runningProgram:
                    # Program is not running, so let the main thread get it.
                    continue

                monitorAfter = programConfig.Monitoring.monitor_after
                if monitorAfter:
                    startTime = runningProgram.getStartTime()
                    if startTime and (time.time() - startTime) < monitorAfter:
                        # Program has not been running long enough to monitor, so wait.
                        continue

                doRestart = False
                if programConfig.Monitoring.activityfile:
                    activityFile = programConfig.Monitoring.activityfile
                    try:
                        if not os.path.exists(activityFile):
                            logMsg('Restarting %s because activity file ( %s ) does not exist\n' %(programName, activityFile,))
                            doRestart = True
                        if doRestart is False:
                            lastModified = os.stat(activityFile).st_mtime
                            threshold = time.time() - programConfig.Monitoring.activityfile_limit
                            if lastModified < threshold:
                                logMsg('Restarting %s because it has not modified activity file ( %s ) in %d seconds. Limit is %d.\n' %(programName, activityFile, int(threshold - lastModified), programConfig.Monitoring.activityfile_limit))
                                doRestart = True
                    except:
                        # We got an exception, just try again.
                        continue
                if doRestart is True:
                    restarting.add(programName)
                    restartProcesses[programName] = subprocess.Popen(['usrsvc', 'restart', programName], shell=False, close_fds=False, stdout=sys.stderr, stderr=sys.stderr)
        except:
            pass
            # If we get an exception, don't fail. Just try, try again.

        time.sleep(5)


def configureStdoutStderr(mainConfig):
    # Configure new stdout and stderr. If there's an issue, the previous is retained, otherwise it is closed.
    if mainConfig.usrsvcd_stdout:
        oldstdout = sys.stdout
        try:
            sys.stdout = open(mainConfig.usrsvcd_stdout, 'at')
        except:
            logErr('Cannot open usrsvcd_stdout ( %s ) for writing.\n' %(mainConfig.usrsvcd_stdout,))
            return 5
        try:
            oldstdout.close()
        except:
            pass
    
    if mainConfig.usrsvcd_stderr:
        oldstderr = sys.stderr
        val = mainConfig.usrsvcd_stderr
        if val == 'stdout':
            sys.stderr = sys.stdout
        else:
            try:
                sys.stderr = open(mainConfig.usrsvcd_stderr, 'at')
            except:
                logErr('Cannot open usrsvcd_stderr ( %s ) for writing.\n' %(mainConfig.usrsvcd_stderr,))
                return 5
        try:
            oldstderr.close()
        except:
            pass
                

    return 0


if __name__ == '__main__':
    if '--help' in sys.argv:
        printUsage()
        sys.exit(1)


    args = sys.argv[1:]
    if len(args) > 1:
        logErr('Too many arguments.\n\n')
        printUsage()
        sys.exit(1)
    
    if args:
        # They provided an action
        arg = args[0]
        if arg == 'checkconfig':
            config = getConfig()
            if not config:
                sys.exit(1)
            sys.exit(0)
        elif arg == 'status':
            config = getConfig()
            if not config:
                logErr('Error in config, cannot check status.\n')
                sys.exit(254)
            usrsvcdProg = getUsrsvcdProg()
            if not usrsvcdProg:
                logErr('usrsvcd is not running.\n')
                sys.exit(1)
            logMsg('usrsvcd is running:\n\n%s\n' %(str(usrsvcdProg),))
            sys.exit(0)
        elif arg == 'reread':
            config = getConfig()
            if not config:
                logErr('Error in config, cannot continue.\n')
                sys.exit(254)
            usrsvcdProg = getUsrsvcdProg()
            if not usrsvcdProg:
                logErr('usrsvcd is not running.\n')
                sys.exit(0) # Not an error condition, because the changes will be applied whenever usrsvcd is started.
            os.kill(usrsvcdProg.pid, signal.SIGUSR1)
            sys.exit(0)
        elif arg == 'restart':
            config = getConfig()
            if not config:
                logErr('Error in config, cannot continue.\n')
                sys.exit(254)
            usrsvcdProg = getUsrsvcdProg()
            if usrsvcdProg:
                try:
                    os.kill(usrsvcdProg.pid, signal.SIGTERM)
                except:
                    # could not send sigterm?
                    if os.path.exists('/proc/%d' %(usrsvcdProg.pid,)):
                        logErr('Cannot terminate existing usrsvcd process:\n\n%s\n' %(str(usrsvcdProg),))
                        sys.exit(1)

                # Wait for process to die cleanly.
                time.sleep(.1)
                now = time.time()
                maxWait = now + 5.0
                while os.path.exists('/proc/%d' %(usrsvcdProg.pid,)):
                    time.sleep(.1)
                    if time.time() > maxWait:
                        # Took too long, send it sig kill.
                        try:
                            os.kill(usrsvcdProg.pid, signal.SIGKILL)
                        except:
                            pass
                        break
            subprocess.Popen(['usrsvcd'], shell=False, close_fds=False, stdout=sys.stdout, stderr=sys.stderr)
            sys.exit(0)
    # END provided action
            
            
    config = getConfig()
    if config is None:
        sys.exit(4)


    mainPidFile = config.mainConfig.pidfile
    usrsvcdProg = getUsrsvcdProg()
    if usrsvcdProg:
        logErr('usrsvcd is already running:\n\n%s\n' %(str(usrsvcdProg),))
        sys.exit(1)

    # Ok, no other process is running, we are good to go. Fork and exit parent. Child continues.
    pid = os.fork()
    if pid != 0:
        sys.exit(0)

    status = configureStdoutStderr(config.mainConfig)
    if status:
        sys.exit(status)

    try:
        with open(mainPidFile, 'wt') as f:
            f.write(str(os.getpid()) + '\n')
    except Exception as e:
        logErr('Failed to write PID file ( %s ): %s\n' %(mainPidFile, str(e)))
        sys.exit(5)
     


    signal.signal(signal.SIGINT, signal.SIG_IGN)
    signal.signal(signal.SIGCHLD, signal.SIG_IGN)
    signal.signal(signal.SIGUSR1, rereadConfig)
    signal.signal(signal.SIGTERM, handle_sigterm)
#    config = usrsvcconfig(os.environ['HOME'] + '/usrsvc.cfg')
#    config.parse()

    # TODO: programWasStarted and programWasSeenRunning may be able to be consolidated into one variable.
    programWasStarted = {}
    programWasSeenRunning = set()
    programLastRestartAttemptAt = {}

    # Number of start attempts per app. Resets to 0 after a successful start.
    numStartAttempts = defaultdict(int)

    startProcesses = {}

    monitoringThread = threading.Thread(target=doMonitoring)
    monitoringThread.start()
    while keepGoing is True:
        programConfigs = config.getProgramConfigs()
        for programName, programConfig in programConfigs.items():
            try:
                if programName in restarting:
                    continue

                if programName in startProcesses:
                    # We ensure that we don't tag the program running when it is still starting by waiting for the pipe to finish.
                    #  usrsvc waits "success_seconds" before determining success.
                    if startProcesses[programName].poll() is None:
                        continue
                    del startProcesses[programName]

                # This goes after the thread check, incase they reload config and change autostart we don't leave a subprocess
                if programConfig.enabled is False or programConfig.autostart is False and programConfig.autorestart is False:
                    # If they don't want this managed by usrsvcd, continue to next program
                    continue


                prog = None
                try:
                    prog = getRunningProgram(programConfig)
                except:
                    pass

                # Record if we found this program started or stopped, for purposes of "autostart" and "autorestart"
                if programName not in programWasStarted:
                    programWasStarted[programName] = bool(prog is not None)

                if prog is not None: 
                    # Program is running, nothing to see here, move along.
                    if programName not in programWasSeenRunning:
                        programWasSeenRunning.add(programName)
                    # Reset our "failed start" counter
                    numStartAttempts[programName] = 0
                    continue

                # Check if we have exceeded the max number of restarts, since last time it was started.
                if programConfig.maxrestarts and numStartAttempts[programName] >= programConfig.maxrestarts:
                    if numStartAttempts[programName] == programConfig.maxrestarts:
                        # If we equal this number, this is the first time we have exceeded max restarts.
                        logMsg('%s has reached the maximum number of restarts %d. Further restarts will not be attempted until the process is seen running again (so manually fix, and run "usrsvc start %s").\n' %(programName, programConfig.maxrestarts, programName))
                        numStartAttempts[programName] += 1
                    continue

                doStart = False
                isRestart = False

                if programConfig.autostart is True and programWasStarted[programName] is False:
                    # Process was not running when we started, and autostart is True, so start it.
                    logMsg("%s was not running and autostart=True. Trying to start [Attempt %d].\n" %(programName, numStartAttempts[programName]+1))
                    programWasStarted[programName] = True
                    doStart = True
                elif programConfig.autorestart is True and (programName in programWasSeenRunning or programWasStarted[programName] is True):
                    # We saw this process running at least once, so autorestart should apply.
                    if programConfig.restart_delay:
                        if programName in programLastRestartAttemptAt:
                            logMsg('[%s] - last restart = %f   delay time = %f\n' %(programName, programLastRestartAttemptAt[programName], (time.time() - programConfig.restart_delay)))
                            if programLastRestartAttemptAt[programName] > (time.time() - programConfig.restart_delay):
                                continue
                    logMsg("%s has stopped running, and autorestart=True. Trying to start [Attempt %d].\n" %(programName, numStartAttempts[programName]+1))
                    doStart = True
                    isRestart = True

                if doStart is True and not programName in restarting:
                    numStartAttempts[programName] += 1
                    if isRestart is True:
                        # We should always do this, whether or not restart_delay is set now, for config-reload reasons.
                        programLastRestartAttemptAt[programName] = time.time()

                    startProcesses[programName] = subprocess.Popen(['usrsvc',  'start', programName], shell=False, close_fds=False, stdout=sys.stdout, stderr=sys.stderr)
            except:
#            except Exception as e:
            
                #logErr('GOT EXCEPTION: %s\n' %(str(e),))
                # If we got a non-specific exception, assume something happened like something restarted the process outside of this loop, and ignore it.
                pass


        time.sleep(2) #TODO: Configurable poll time
    
    monitoringThread.join()
