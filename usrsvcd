#!/usr/bin/env python



import os
import sys
import signal
import subprocess
import time
import traceback

from usrsvcmod.config import config as usrsvcconfig
from usrsvcmod.Program import Program
from usrsvcmod.ProgramActions import getRunningProgram

class VarStore(object):
    def __init__(self):
        self.value = None

    def setValue(self, value):
        self.value = value

    def getValue(self):
        return self.value


def printUsage():
    sys.stderr.write('Usage: usrsvcd\n  Optional daemon which monitors processes and keeps them running, and other optional features.\n\nUses config file in $HOME/usrsvc.cfg (%s)\n' %(os.environ['HOME'] + '/usrsvc.cfg',))


global config
config = None

def rereadConfig(*args, **kwargs):
    global config

    sys.stdout.write('Got SIGUSR1, reprocessing config.\n')
    try:
        config2 = usrsvcconfig(os.environ['HOME'] + '/usrsvc.cfg')
        config2.parse()
    except Exception as e:
        sys.stderr.write('FAILED TO REREAD CONFIG: %s\n' %(str(e),))
        traceback.print_exc()

    config = config2
    
# TODO: Configurable stdout/stderr file

if __name__ == '__main__':
    if '--help' in sys.argv or len(sys.argv) > 1:
        printUsage()
        sys.exit(1)

    config = usrsvcconfig(os.environ['HOME'] + '/usrsvc.cfg')
    config.parse()
    mainPidFile = config.mainConfig.pidfile
    try:
        prog = Program.createFromPidFile(mainPidFile)
        if prog and 'usrsvcd' in prog.cmdline:
            sys.stderr.write('usrsvcd is already running:\n%s\n' %(str(prog.__dict__),))
        f = open(mainPidFile, 'r')
        contents = f.read()
        f.close()
    except:
        pass
        

    pid = os.fork()
    if pid != 0:
        sys.exit(0)

    with open(mainPidFile, 'wt') as f:
        f.write(str(os.getpid()) + '\n')
     
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    signal.signal(signal.SIGCHLD, signal.SIG_IGN)
    signal.signal(signal.SIGUSR1, rereadConfig)
#    config = usrsvcconfig(os.environ['HOME'] + '/usrsvc.cfg')
#    config.parse()

    processWasStarted = {}
    processWasSeenRunning = set()

    startProcesses = {}
    while True:
        programConfigs = config.getProgramConfigs()
        for programName, programConfig in programConfigs.items():
            if programName in startProcesses:
                if startProcesses[programName].poll() is None:
                    continue
                del startProcesses[programName]

            # This goes after the thread check, incase they reload config and change autostart we don't leave a subprocess
            if programConfigs.enabled is False or programConfig.autostart is False and programConfig.autorestart is False:
                # If they don't want this managed by usrsvcd, continue to next program
                continue


            prog = None
            try:
                prog = getRunningProgram(programConfig)
            except:
                pass

            # Record if we found this program started or stopped, for purposes of "autostart" and "autorestart"
            if programName not in processWasStarted:
                processWasStarted[programName] = bool(prog is not None)

            if prog is not None: 
                # Program is running, nothing to see here, move along.
                if programName not in processWasSeenRunning:
                    processWasSeenRunning.add(programName)
                continue

            doStart = False

            if programConfig.autostart is True and processWasStarted[programName] is False:
                # Process was not running when we started, and autostart is True, so start it.
                sys.stdout.write("%s was not running and autostart=True. Trying to start.\n" %(programName,))
                sys.stdout.flush()
                processWasStarted[programName] = True
                doStart = True
            elif programConfig.autorestart is True and programName in processWasSeenRunning:
                # We saw this process running at least once, so autorestart should apply.
                sys.stdout.write("%s has stopped running, and autorestart=True. Trying to start.\n" %(programName,))
                sys.stdout.flush()
                doStart = True

            if doStart is True:
                startProcesses[programName] = subprocess.Popen(['usrsvc',  'start', programName], shell=False, close_fds=False)


        time.sleep(2) #TODO: Configurable poll time
            
            
