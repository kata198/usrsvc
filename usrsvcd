#!/usr/bin/env python



import os
import sys
import signal
import subprocess
import time
import traceback

from collections import defaultdict

from usrsvcmod.config import config as usrsvcconfig
from usrsvcmod.Program import Program
from usrsvcmod.ProgramActions import getRunningProgram

class VarStore(object):
    def __init__(self):
        self.value = None

    def setValue(self, value):
        self.value = value

    def getValue(self):
        return self.value


def printUsage():
    sys.stderr.write('Usage: usrsvcd\n  Optional daemon which monitors processes and keeps them running, and other optional features.\n\nUses config file in $HOME/usrsvc.cfg (%s)\n' %(os.environ['HOME'] + '/usrsvc.cfg',))


global config
config = None

def rereadConfig(*args, **kwargs):
    global config

    sys.stdout.write('Got SIGUSR1, reprocessing config.\n')
    try:
        config2 = usrsvcconfig(os.environ['HOME'] + '/usrsvc.cfg')
        config2.parse()
    except Exception as e:
        sys.stderr.write('FAILED TO REREAD CONFIG: %s\n' %(str(e),))
        traceback.print_exc()

    config = config2
    
# TODO: Configurable stdout/stderr file

if __name__ == '__main__':
    if '--help' in sys.argv or len(sys.argv) > 1:
        printUsage()
        sys.exit(1)

    config = usrsvcconfig(os.environ['HOME'] + '/usrsvc.cfg')
    config.parse()
    mainPidFile = config.mainConfig.pidfile
    try:
        prog = Program.createFromPidFile(mainPidFile)
        if prog and 'usrsvcd' in prog.cmdline:
            sys.stderr.write('usrsvcd is already running:\n%s\n' %(str(prog.__dict__),))
        f = open(mainPidFile, 'r')
        contents = f.read()
        f.close()
    except:
        pass
        

    pid = os.fork()
    if pid != 0:
        sys.exit(0)

    with open(mainPidFile, 'wt') as f:
        f.write(str(os.getpid()) + '\n')
     
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    signal.signal(signal.SIGCHLD, signal.SIG_IGN)
    signal.signal(signal.SIGUSR1, rereadConfig)
#    config = usrsvcconfig(os.environ['HOME'] + '/usrsvc.cfg')
#    config.parse()

    # TODO: processWasStarted and processWasSeenRunning may be able to be consolidated into one variable.
    processWasStarted = {}
    processWasSeenRunning = set()

    # Number of start attempts per app. Resets to 0 after a successful start.
    numStartAttempts = defaultdict(int)

    startProcesses = {}
    while True:
        programConfigs = config.getProgramConfigs()
        for programName, programConfig in programConfigs.items():

            if programName in startProcesses:
                # We ensure that we don't tag the program running when it is still starting by waiting for the pipe to finish.
                #  usrsvc waits "success_seconds" before determining success.
                if startProcesses[programName].poll() is None:
                    continue
                del startProcesses[programName]

            # This goes after the thread check, incase they reload config and change autostart we don't leave a subprocess
            if programConfig.enabled is False or programConfig.autostart is False and programConfig.autorestart is False:
                # If they don't want this managed by usrsvcd, continue to next program
                continue


            prog = None
            try:
                prog = getRunningProgram(programConfig)
            except:
                pass

            # Record if we found this program started or stopped, for purposes of "autostart" and "autorestart"
            if programName not in processWasStarted:
                processWasStarted[programName] = bool(prog is not None)

            if prog is not None: 
                # Program is running, nothing to see here, move along.
                if programName not in processWasSeenRunning:
                    processWasSeenRunning.add(programName)
                # Reset our "failed start" counter
                numStartAttempts[programName] = 0
                continue

            # Check if we have exceeded the max number of restarts, since last time it was started.
            if programConfig.maxrestarts and numStartAttempts[programName] >= programConfig.maxrestarts:
                if numStartAttempts[programName] == programConfig.maxrestarts:
                    # If we equal this number, this is the first time we have exceeded max restarts.
                    sys.stdout.write('%s has reached the maximum number of restarts %d. Further restarts will not be attempted until the process is seen running again (so manually fix, and run "usrsvc start %s").\n' %(programName, programConfig.maxrestarts, programName))
                    sys.stdout.flush()
                    numStartAttempts[programName] += 1
                continue

            doStart = False

            if programConfig.autostart is True and processWasStarted[programName] is False:
                # Process was not running when we started, and autostart is True, so start it.
                sys.stdout.write("%s was not running and autostart=True. Trying to start [Attempt %d].\n" %(programName, numStartAttempts[programName]+1))
                sys.stdout.flush()
                processWasStarted[programName] = True
                doStart = True
            elif programConfig.autorestart is True and (programName in processWasSeenRunning or processWasStarted[programName] is True):
                # We saw this process running at least once, so autorestart should apply.
                sys.stdout.write("%s has stopped running, and autorestart=True. Trying to start [Attempt %d].\n" %(programName, numStartAttempts[programName]+1))
                sys.stdout.flush()
                doStart = True

            if doStart is True:
                numStartAttempts[programName] += 1
                # TODO in order to implement restartdelay, launching this subprocess needs to go into a thread. Or probably a better option,
                #  is to not use the subprocess module and just os.fork -> exec, and incorporate the sleep therein,
                startProcesses[programName] = subprocess.Popen(['usrsvc',  'start', programName], shell=False, close_fds=False)


        time.sleep(2) #TODO: Configurable poll time
            
            
